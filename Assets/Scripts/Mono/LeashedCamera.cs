using UnityEngine;
using UnityEngine.InputSystem;

public class LeashedCamera : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private Transform player; // Reference to the player object

    [Header("Camera Settings")]
    [SerializeField] private float cameraHeight = 10f; // Constant height of the camera
    [SerializeField] private Vector3 defaultOffset = new Vector3(0, 0, -5f); // Default offset behind the player
    [SerializeField] private float followDamping = 5f; // Damping for smooth following
    [SerializeField] private float snapBackDamping = 3f; // Damping for snapping back to the original offset
    [SerializeField] private float maxPanDistance = 2f; // Maximum distance to pan in the XZ plane

    private Vector3 currentOffset; // Current offset including panning
    private Vector3 panInput; // Input from the right stick for panning
    private Vector3 velocity = Vector3.zero; // Velocity for smooth damping

    // Input Action asset generated by the new Input System
    private InputSystem_Actions inputActions;

    private void Awake()
    {
        // Initialize the Input System actions
        inputActions = new InputSystem_Actions();

        // Enable the input action map (usually it's called "Player" in generated InputSystem_Actions)
        inputActions.Player.Enable();
    }

    private void OnEnable()
    {
        // Subscribe to the right stick input (Look action)
        inputActions.Player.Look.performed += OnLookPerformed;
        inputActions.Player.Look.canceled += OnLookCanceled;
    }

    private void OnDisable()
    {
        // Unsubscribe from the right stick input
        inputActions.Player.Look.performed -= OnLookPerformed;
        inputActions.Player.Look.canceled -= OnLookCanceled;

        inputActions.Player.Disable();
    }

    private void Start()
    {
        // Start with the default offset
        currentOffset = defaultOffset;
    }

    private void LateUpdate()
    {
        if (player == null) return;

        // Handle panning based on right stick input
        HandlePanning();

        // Calculate target position (player position + offset + pan)
        Vector3 targetPosition = player.position + currentOffset;
        targetPosition.y = cameraHeight +player.position.y; // Fix the height

        // Smoothly move the camera towards the target position
        transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref velocity, followDamping);

        // Maintain constant overhead rotation
        //transform.rotation = Quaternion.Euler(90f, 0f, 0f);
    }

    // Handle panning based on the right stick input and smoothly return to the default offset
    private void HandlePanning()
    {
        if (panInput.sqrMagnitude > 0.1f)
        {
            // Allow panning within the defined max distance
            Vector3 panOffset = new Vector3(panInput.x, 0f, panInput.y) * maxPanDistance;
            currentOffset = defaultOffset + panOffset;
        }
        else
        {
            // Smoothly snap back to the default offset when the stick is released
            currentOffset = Vector3.Lerp(currentOffset, defaultOffset, Time.deltaTime * snapBackDamping);
        }
    }

    // Called when the Look (right stick) input is performed
    private void OnLookPerformed(InputAction.CallbackContext context)
    {
        // Get the Vector2 input from the right stick (Look)
        panInput = context.ReadValue<Vector2>();
    }

    // Called when the Look (right stick) input is canceled (stick released)
    private void OnLookCanceled(InputAction.CallbackContext context)
    {
        // Reset the pan input when the stick is released
        panInput = Vector2.zero;
    }
}
